[[wildfly_grpc_introduction]]
## WildFly grpc subsystem

*gRPC* is a _Remote Procedure Call_ framework defined and supported by Google (https://grpc.io/).
It is notable for a number of benefits:

* It is based on a language neutral _Interface Definition Language_ (_IDL_) that supports numerous
programming languages, including, of course, Java.

* It has a compact wire format and runs over HTTP2, leading to fast transmission.

The WildFly *grpc* subsystem supports exposing one or more gRPC services to gRPC clients.

### Interface Definition Language

The basic IDL comes from the *protobuf* project, also supported by Google (https://developers.google.com/protocol-buffers).
Basic IDL supports the definition of message types; for example

```
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.wildfly.extension.grpc.example.helloworld";
option java_outer_classname = "HelloWorldProto";

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```
is a simplified version of wildfly-grpc-feature-pack/examples/helloworld/proto/src/main/proto/helloworld.proto.
The message types `HelloRequest` and `HelloReply` each have a single field with builtin type `string`. Note that
each field in a message is associated with an integer, which helps with translation to and from the wire format and
also helps with versioning.

gRPC contributes a compiler plugin that supports remote procedure call definitions. For example, the following
definition also comes from helloworld.proto:

```
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}
```
Here, `SayHello` is the name of the method, `HelloRequest` is the type of argument, and `HelloReply`
is the type of the return value.

*Note.* An alternative syntax for rpc definitions uses `{}` instead of `;`.
```
  rpc SayHello (HelloRequest) returns (HelloReply) {}
```
They have the same meaning, except that `{}` can be used to pass values to plugins.

### Compiler output

For a given target language, the protobuf compiler plus the gRPC plugin generate code from the IDL file 
for use on the server and client side. Consider `org.wildfly.extension.grpc.example.helloworld.HelloRequest`
in wildfly-grpc-feature-pack/examples/helloworld/client/target/generated-sources/protobuf/java/, generated by the
protobuf compiler. `org.wildfly.extension.grpc.example.helloworld.GreeterClient` in 
wildfly-grpc-feature-pack/examples/helloworld/client uses it to create an instance of `HelloRequest`:

```
HelloRequest request = HelloRequest.newBuilder().setName(name).build();
```

Also, consider `org.wildfly.extension.grpc.example.helloworld.GreeterGrpc` in 
wildfly-grpc-feature-pack/examples/helloworld/service/target/generated-sources/protobuf/grpc-java, generated by
the grpc plugin. The internal class `GreeterImplBase` has method

```
public void sayHello(org.wildfly.extension.grpc.example.helloworld.HelloRequest request,
        io.grpc.stub.StreamObserver<org.wildfly.extension.grpc.example.helloworld.HelloReply> responseObserver) 
```

which is derived from the rpc `sayHello` definition. This method will throw an exception. The point is that
`GreeterImplBase` is meant to be overridden with useful code. For example,
`org.wildfly.extension.grpc.example.helloworld.GreeterServiceImpl.sayHello()`
in wildfly-grpc-feature-pack/examples/helloworld/service takes a name and returns a greeting.

`GreeterServiceImpl` is a gRPC service which is meant to be installed in a gRPC server, which looks something like this:

```
io.grpc.Server server = ServerBuilder.forPort(9555)
                            .addService(new GreeterServiceImpl())
                            .build()
                            .start();
```

The `Server` listens on port 9555 and dispatches an incoming message to the appropriate service.

`GreeterGrpc` also has inner class `GreeterBlockingStub` for use on the client side. Consider class
`org.wildfly.extension.grpc.example.helloworld.GreeterClient` in wildfly-grpc-feature-pack/examples/helloworld/client/.
[Note. The code from `GreeterClient` is somewhat modified here for simplicity.] It creates a `GreeterBlockingStub`

```
ManagedChannel channel = ManagedChannelBuilder.forTarget("localhost:9555")
                             .usePlaintext()
                             .build();
GreeterBlockingStub blockingStub = GreeterGrpc.newBlockingStub(channel);
```

and uses it to send a message to the server:

```
HelloRequest request = HelloRequest.newBuilder().setName(name).build();
HelloReply response = blockingStub.sayHello(request);
logger.info("Greeting: " + response.getMessage());
```

### WildFly grpc subsystem

The WildFly subsystem grpc allows WildFly to expose multiple gRPC services. It uses a 
`io.grpc.netty.NettyServerBuilder` to create an `io.grpc.Server` and then registers all of the
gRPC services that it discovers in available deployments. A gRPC service is a class that
implements `io.grpc.BindableService`. See, for example, the inner class
`GreeterGrpc.GreeterImplBase`, which is subclassed by
`org.wildfly.extension.grpc.example.helloworld.GreeterServiceImpl`.

`NettyServerBuilder` extends `io.grpc.internal.AbstractServerImplBuilder<NettyServerBuilder>`
which extends `io.grpcl.ServerBuilder`. All of these have a number of parameters, and they are
exposed by the grpc subsystem. Of the numerical parameters, some have type `int` and some have
type `long`, and the grpc subsystem preserves those types. For time span parameters,
the set methods take a `java.util.concurrent.TimeUnit` parameter, but
for simplicity, the grpc subsystem treats those time span parameters as signifying seconds.

Most of the parameters are derived from `NettyServerBuilder` and its super classes. Some others apply
to the SSL configuration.

Most of the following descriptions are derived from the javadoc on the setter methods.

* *flow-control-window*: Sets the flow control window in bytes. Setting flowControlWindow disables auto flow control
   tuning; use "initial-flow-control-window" to enable auto flow control tuning. If not
   called, the default value is 1024 * 1024 with auto flow control tuning. The type is `int` and the unit is seconds.

* *handshake-timeout*:  Sets the permitted time for new connections to complete negotiation handshakes before being
   killed. The type is `long` and the unit is seconds.
   
* *initial-flow-control-window*: Sets the initial flow control window in bytes. Setting initial flow control window enables auto
   flow control tuning using bandwidth-delay product algorithm. To disable auto flow control
   tuning, use "flow-control-window". By default, auto flow control is enabled with
   initial flow control window size of 1024 * 1024. The type is `int` and the unit is seconds.
   
* *keep-alive-time*: Sets a custom keepalive time, the delay time for sending next keepalive ping. An unreasonably
   small value might be increased, and `Long.MAX_VALUE` seconds or an unreasonably
   large value will disable keepalive. The default is two hours. The type is `long` and the unit is seconds.

* *keep-alive-timeout*: Sets a custom keepalive timeout, the timeout for keepalive ping requests. An unreasonably small
   value might be increased. The default is 20 seconds. The type is `long` and the unit is seconds.

* *key-manager-name*: Refers to a key manager defined in the Elytron subsystem. The type is `String`, and the default value
   is "applicationKM".

* *max-concurrent-calls-per-connection*: The maximum number of concurrent calls permitted for each incoming connection. Defaults to no
   limit. The type is `int`.
   
* *max-connection-age*: Sets a custom max connection age; a connection lasting longer than which will be gracefully
   terminated. An unreasonably small value might be increased.  A random jitter of +/-10% will be
   added to it. `Long.MAX_VALUE` seconds or an unreasonably large value will disable
   max connection age. The type is `long` and the unit is seconds. The default value disables max connection age.
   
* *max-connection-age-grace*: Sets a custom grace time for the graceful connection termination. Once the max connection age
   is reached, RPCs have the grace time to complete. RPCs that do not complete in time will be
   cancelled, allowing the connection to terminate. `Long.MAX_VALUE` seconds or an
   unreasonably large value are considered infinite. The type is `long` and the unit is seconds. The default value is
   essentially infinite.
   
* *max-connection-idle*: Sets a custom max connection idle time; connections being idle for longer than which will be
   gracefully terminated. Idleness duration is defined since the most recent time the number of
   outstanding RPCs became zero or the connection establishment. An unreasonably small value might
   be increased. `Long.MAX_VALUE` seconds or an unreasonably large value will disable max connection idle.
   The type is `long` and the unit is seconds. The default value is essentially infinite.
   
* *max-inbound-message-size*: Sets the maximum message size allowed to be received on the server. If not set,
   defaults to 4 MiB. The default provides protection to servers who haven't considered the
   possibility of receiving large messages while trying to be large enough to not be hit in normal
   usage. The default is 4 * 1024 * 1024. The type is `int`.

* *max-inbound-metadata-size*: Sets the maximum size of metadata allowed to be received. This is cumulative size of the
   entries with some overhead, as defined for http://httpwg.org/specs/rfc7540.html#rfc.section.6.5.2
   HTTP/2's SETTINGS_MAX_HEADER_LIST_SIZE. The default is 8 KiB. The type is `int`.

* *permit-keep-alive-time*: Specify the most aggressive keep-alive time clients are permitted to configure. The server will
   try to detect clients exceeding this rate and when detected will forcefully close the
   connection. The default is 5 minutes. The type is `long` and the unit is seconds. *Note.* Even though a default is
   defined that allows some keep-alives, clients must not use
   keep-alive without approval from the service owner. Otherwise, they may experience failures in
   the future if the service becomes more restrictive. When unthrottled, keep-alives can cause a
   significant amount of traffic and CPU usage, so clients and servers should be conservative in
   what they use and accept.

* *permit-keep-alive-without-calls*: Sets whether to allow clients to send keep-alive HTTP/2 PINGs even if there are no outstanding
   RPCs on the connection. The type is `boolean`, and the default is false.

* *protocol-provider*: Sets the `SslContext` implementation to use. The type is `String`. The default is
   OPENSSL if it is available. Otherwise, the default is JDK.

* *server-host*: The host to which the server is to be bound. The type is `String`, and the default is "localhost".

* *server-port*: The port to which the server is to be bound. The type is `int` and the default is 9555.

* *session-cache-size*: Set the size of the cache used for storing SSL session objects. The type is `long` and the
   default depends on the `SslContext` implementation.

* *session-timeout*: Set the timeout for the cached SSL session objects, in seconds. The type is `long` and the
   default depends on the `SslContext` implementation.

* *shutdown-timeout*: Sets the time that the server should wait to become terminated, giving up if the timeout
   is reached. The type is `int`, and the default is 3 seconds.

* *ssl-context-name*: Refers to an SSL Context defined in the Elytron subsystem. The type is `String` and no value
   is set by default.
  
* *start-tls*: Sets whether the first write request shouldn't be encrypted. The type is `boolean` and the default
   depends on the `SslContext` implementation.
   
* *trust-manager-name*: Refers to a trust manager defined in the Elytron subsystem. The type is `String`. No trust manager
   is set by default.
   
*Note.* Most of these parameters have default values set in the gRPC runtime, and the grpc subsystem leaves them alone
by default. Six of them, "key-manager-name", "server-host", "server-port", "shutdown-timeout", "ssl-context-name", and
"trust-manager-name", are explicitly set by the grpc subsystem to the values described above.
   
### Security

The grpc subsystem mainly depends on Elytron (https://docs.wildfly.org/27/WildFly_Elytron_Security.html) 
for SSL/TLS configuration. For example, the parameter "key-manager-name"
is used to retrieve a key manager from Elytron. If gRPC communication is meant to take place over SSL/TLS connections,
then "key-manager-name" is required. Conversely, if non-secure connections are desired, then "key-manager-name" must be
set to "". The default value is "applicationKM", which comes in WildFly out of the box.

The parameter "ssl-context-name" refers to an SSL context configured in Elytron. If "ssl-context-name" is not null,
then the SSL context can be used to supply the following additional values:

* enabled cipher suites
* enabled protocols, e.g., "TLSv1.2"
* SSL context provider

If set, the "protocol-provider" parameter overrides the value retrieved from the SSL context. The default value of 
"ssl-context-name" is null.

The parameter "trust-manager-name" refers to a trust manager configured in Elytron, which is necessary only if
client identities are meant to be verified. By default it is set to null.

The parameters "session-cache-size", "session-timeout", and "start-tls" also apply to SSL/TLS connections. No default
values are set by the grpc subsystem.
